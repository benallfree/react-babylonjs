---
title: 'Initializing Babylon.js'
---

import { Engine, Scene } from 'react-babylonjs'
import { Color3, Vector3 } from '@babylonjs/core'

You can program Babylon.js declaratively just like any React application.

# Step 1: Create a basic React skeleton

Begin by creating an `index.tsx` and `App.tsx` (or `index.js` and `App.js` if
you prefer).

```typescript
// index.tsx

import { render } from 'react-dom'
import App from './App'

const rootElement = document.getElementById('root')
render(<App />, rootElement)
```

and

```typescript
// App.tsx

import { FC } from 'react'

const App: FC = () => (
  <div style={{ flex: 1, display: 'flex' }}>Hello, React!</div>
)

export default App
```

The result looks like:

<ReactDemo>
  <div style={{ flex: 1, display: 'flex' }}>Hello, React!</div>
</ReactDemo>

# Step 2: Add Babylon.js `<Engine>` and `<Scene>`

So far, so good. Boilerplate React. Now let's begin to add some magic to
`App.tsx` by replacing the `Hello React!` with Babylon.js bootstrapping.

### The _old_ way

Normally, you would need to initialize a Babylon.js
[Engine](https://doc.babylonjs.com/typedoc/classes/babylon.engine) and
[Scene](https://doc.babylonjs.com/start/chap1/first_scene#say-hello-to-your-first-world)
along with a camera, light, and object to view.

```typescript
// The old way. We dislike it.

import * as BABYLON from '@babylonjs/core'

var canvas = document.getElementById('renderCanvas')
const engine = new BABYLON.Engine(canvas, true, {
  preserveDrawingBuffer: true,
  stencil: true,
  disableWebGL2Support: false,
})
const scene = new BABYLON.Scene(engine)
const camera = new BABYLON.ArcRotateCamera(
  'camera',
  -Math.PI / 2,
  Math.PI / 2.5,
  3,
  new BABYLON.Vector3(0, 0, 0),
  scene
)
camera.attachControl(canvas, true)
const light = new BABYLON.HemisphericLight(
  'light',
  new BABYLON.Vector3(0, 1, 0),
  scene
)
const box = BABYLON.MeshBuilder.CreateBox('box', {}, scene)
```

### The _new_ way

The above is a lot of imperitive programming. If we've learned anything over the
last few years, we've learned that the benefits of declarative programming are
clear and numerous for large applications. So, we can do this instead:

```typescript
// App.tsx

import { FC } from 'react'
import { Engine, Scene } from 'react-babylonjs'

export const rpm = 5
const App: FC = () => (
  <div style={{ flex: 1, display: 'flex' }}>
    <Engine antialias adaptToDeviceRatio canvasId="babylonJS">
      <Scene>
        <freeCamera
          name="camera1"
          position={new Vector3(0, 5, -10)}
          setTarget={[Vector3.Zero()]}
        />
        <hemisphericLight
          name="light1"
          intensity={0.7}
          direction={Vector3.Up()}
        />
        <box
          name="box"
          size={2}
          position={new Vector3(1, 1, 1)}
          rotation={new Vector3(2, 2, 0)}
        >
          <standardMaterial
            name="material"
            diffuseColor={Color3.Red()}
            specularColor={Color3.Black()}
          />
        </box>
      </Scene>
    </Engine>
  </div>
)

export default App
```

That will render something like this:

<ReactDemo>
  <Engine antialias adaptToDeviceRatio canvasId="babylonJS">
    <Scene>
      <freeCamera
        name="camera1"
        position={new Vector3(0, 5, -10)}
        setTarget={[Vector3.Zero()]}
      />
      <hemisphericLight
        name="light1"
        intensity={0.7}
        direction={Vector3.Up()}
      />
      <box
        name="box"
        size={2}
        position={new Vector3(1, 1, 1)}
        rotation={new Vector3(2, 2, 0)}
      >
        <standardMaterial
          name="material"
          diffuseColor={Color3.Red()}
          specularColor={Color3.Black()}
        />
      </box>
    </Scene>
  </Engine>

</ReactDemo>

### Step 3: Try it yourself

Here's a complete Codesandbox project to play with.

<Sandbox name="basic-skeleton" />
