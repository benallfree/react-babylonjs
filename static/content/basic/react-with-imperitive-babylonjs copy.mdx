---
title: 'Plain Old React + Babylon.js'
---

Once you have a React project set up, you can program Babylon.js imperitively
just like they tell you in the
[official Babylon.js + React guide](https://doc.babylonjs.com/extensions/Babylon.js+ExternalLibraries/BabylonJS_and_ReactJS).

```tsx codesandbox=rbjs?entry=./src/App.tsx
import {
  Engine,
  EngineOptions,
  FreeCamera,
  HemisphericLight,
  MeshBuilder,
  Scene,
  SceneOptions,
  Vector3,
} from '@babylonjs/core'
import React, { FC, useEffect, useRef } from 'react'
// import SceneComponent from 'babylonjs-hook'; // if you install 'babylonjs-hook' NPM.

type SceneComponentProps = {
  canvasId?: string
  antialias?: boolean
  engineOptions?: EngineOptions
  adaptToDeviceRatio?: boolean
  sceneOptions?: SceneOptions
  onRender: (scene: Scene) => void
  onSceneReady?: (scene: Scene) => void
}

const SceneComponent: FC<Partial<SceneComponentProps>> = (props) => {
  const reactCanvas = useRef(null)
  const _props: SceneComponentProps = {
    canvasId: 'babylonjs-canvas',
    onRender: () => console.log('Scene is ready, override onRender'),
    onSceneReady: () => console.log('Scene is ready, override onSceneReady'),
    ...props,
  }

  const {
    antialias,
    engineOptions,
    adaptToDeviceRatio,
    sceneOptions,
    onRender,
    onSceneReady,
    ...rest
  } = _props

  useEffect(() => {
    if (reactCanvas.current) {
      const engine = new Engine(
        reactCanvas.current,
        antialias,
        engineOptions,
        adaptToDeviceRatio
      )
      const scene = new Scene(engine, sceneOptions)
      if (scene.isReady()) {
        onSceneReady(scene)
      } else {
        scene.onReadyObservable.addOnce((scene) => onSceneReady(scene))
      }

      engine.runRenderLoop(() => {
        if (typeof onRender === 'function') {
          onRender(scene)
        }
        // scene.render()
      })

      const resize = () => {
        scene.getEngine().resize()
      }

      if (window) {
        window.addEventListener('resize', resize)
      }

      return () => {
        scene.getEngine().dispose()

        if (window) {
          window.removeEventListener('resize', resize)
        }
      }
    }
  }, [reactCanvas])

  return <canvas id={id} ref={reactCanvas} {...rest} />
}

let box

const onSceneReady = (scene) => {
  console.log('scene ready')
  // This creates and positions a free camera (non-mesh)
  var camera = new FreeCamera('camera1', new Vector3(0, 5, -10), scene)

  // This targets the camera to scene origin
  camera.setTarget(Vector3.Zero())

  const canvas = scene.getEngine().getRenderingCanvas()

  // This attaches the camera to the canvas
  camera.attachControl(canvas, true)

  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
  var light = new HemisphericLight('light', new Vector3(0, 1, 0), scene)

  // Default intensity is 1. Let's dim the light a small amount
  light.intensity = 0.7

  // Our built-in 'box' shape.
  box = MeshBuilder.CreateBox('box', { size: 2 }, scene)

  // Move the box upward 1/2 its height
  box.position.y = 1

  // Our built-in 'ground' shape.
  MeshBuilder.CreateGround('ground', { width: 6, height: 6 }, scene)
}

/**
 * Will run on every frame render.  We are spinning the box on y-axis.
 */
const onRender = (scene) => {
  if (box !== undefined) {
    var deltaTimeInMillis = scene.getEngine().getDeltaTime()

    const rpm = 10
    box.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000)
  }
}

export default () => (
  <div>
    <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} />
  </div>
)
```

Alternatively, you can use
[babylonjs-hook](https://www.npmjs.com/package/babylonjs-hook) which basically
replaces `SceneComponent`:

```tsx codesandbox=rbjs?entry=./src/App.tsx
import {
  FreeCamera,
  HemisphericLight,
  MeshBuilder,
  Vector3,
} from '@babylonjs/core'
import SceneComponent from 'babylonjs-hook' // if you install 'babylonjs-hook' NPM.
import React from 'react'

let box

const onSceneReady = (scene) => {
  console.log('scene ready')
  // This creates and positions a free camera (non-mesh)
  var camera = new FreeCamera('camera1', new Vector3(0, 5, -10), scene)

  // This targets the camera to scene origin
  camera.setTarget(Vector3.Zero())

  const canvas = scene.getEngine().getRenderingCanvas()

  // This attaches the camera to the canvas
  camera.attachControl(canvas, true)

  // This creates a light, aiming 0,1,0 - to the sky (non-mesh)
  var light = new HemisphericLight('light', new Vector3(0, 1, 0), scene)

  // Default intensity is 1. Let's dim the light a small amount
  light.intensity = 0.7

  // Our built-in 'box' shape.
  box = MeshBuilder.CreateBox('box', { size: 2 }, scene)

  // Move the box upward 1/2 its height
  box.position.y = 1

  // Our built-in 'ground' shape.
  MeshBuilder.CreateGround('ground', { width: 6, height: 6 }, scene)
}

/**
 * Will run on every frame render.  We are spinning the box on y-axis.
 */
const onRender = (scene) => {
  if (box !== undefined) {
    var deltaTimeInMillis = scene.getEngine().getDeltaTime()

    const rpm = 10
    box.rotation.y += (rpm / 60) * Math.PI * 2 * (deltaTimeInMillis / 1000)
  }
}

export default () => (
  <div>
    <SceneComponent antialias onSceneReady={onSceneReady} onRender={onRender} />
  </div>
)
```

And you'll get the same thing:

# Step 2: Add Babylon.js `<Engine>` and `<Scene>`

So far, so good. Boilerplate React. Now let's begin to add some magic to
`App.tsx` by replacing the `Hello React!` with Babylon.js bootstrapping.

### The _old_ way

Normally, you would need to initialize a Babylon.js
[Engine](https://doc.babylonjs.com/typedoc/classes/babylon.engine) and
[Scene](https://doc.babylonjs.com/start/chap1/first_scene#say-hello-to-your-first-world)
along with a camera, light, and object to view.

```typescript
// The old way. We dislike it.

import * as BABYLON from '@babylonjs/core'

var canvas = document.getElementById('renderCanvas')
const engine = new BABYLON.Engine(canvas, true, {
  preserveDrawingBuffer: true,
  stencil: true,
  disableWebGL2Support: false,
})
const scene = new BABYLON.Scene(engine)
const camera = new BABYLON.ArcRotateCamera(
  'camera',
  -Math.PI / 2,
  Math.PI / 2.5,
  3,
  new BABYLON.Vector3(0, 0, 0),
  scene
)
camera.attachControl(canvas, true)
const light = new BABYLON.HemisphericLight(
  'light',
  new BABYLON.Vector3(0, 1, 0),
  scene
)
const box = BABYLON.MeshBuilder.CreateBox('box', {}, scene)
```

### The _new_ way

The above is a lot of imperitive programming. If we've learned anything over the
last few years, we've learned that the benefits of declarative programming are
clear and numerous for large applications. So, we can do this instead:

### Step 3: Try it yourself

Here's a complete Codesandbox project to play with.

<Sandbox name="basic-skeleton" />
